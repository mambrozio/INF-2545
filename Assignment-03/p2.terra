#include "/home/terra/TerraNG/terra/TerraNet.defs"

// defines
#define MAXIMUM_TEMPERATURE (510)
#define INITIAL_ROUTE       (0)
#define ID                  (getNodeId())

// macros: leds
#define RED    1
#define GREEN  2
#define YELLOW 4
#define ALL    7
#define BLINK(led) emit LEDS(led); await 1s; emit LEDS(OFF);

// macros: successors table
#define UNREACHABLE 0

#define GRID_WIDTH      4
#define GRID_HEIGHT     4
#define SUCCESSORS_SIZE 16

#define J(n)         (n%10)        // column in the grid
#define I(n)         ((n-J(n))/10) // row in the grid
#define INDEX(n)     (GRID_WIDTH * (I(n)-1) + (J(n)-1))
#define SUCCESSOR(n) successors[INDEX(n)]

// messages
#define ALARM   3
#define ECHO    5
#define FLOOD   7
#define REQUEST 9

pktype generic_msg from radioMsg with
    // ALARM   : node that measured the temperature value
    // FLOOD   : origin (parent node id)
    // REQUEST : destination
    var ushort v1;
    // ALARM   : temperature value
    // FLOOD   : route (known route)
    var ushort v2;
    // FLOOD   : jumps (number of jumps to root)
    var ushort v3;
end

pktype echo_msg from radioMsg with
    var ubyte[SUCCESSORS_SIZE] successors;
end

// auxiliary
var generic_msg message;

// successors table
var ubyte[SUCCESSORS_SIZE] successors;
loop i, SUCCESSORS_SIZE do
    successors[i] = UNREACHABLE;
end

// ----------------------------------------
//
if ID == 11 then // gateway
//
// ----------------------------------------

par do
    // processes a message from the queue 
    loop do
        await Q_READY;
        loop do
            // checks if the queue has elements
            if qSize() <= 0 then
                break;
            end
            qGet(message);
            if message.type == ALARM then
                // targets tossam
                message.v3 /* jumps */ = 100;
                message.target = 1;
            end
            // sends the message
            emit SEND(message);
            await SEND_DONE;
        end
    end
with
    // waits for an alarm
    loop do 
        message = await RECEIVE(ALARM);
        qPut(message);
    end
with
    // sends request temperature message
    // (if photo value is higher than 400)
    loop do
        emit REQ_PHOTO();
        var ushort value = await PHOTO;
        if value > 400 then
            var ushort destination = 44; // arbitrary
            message.v1 /* destination */ = destination;
            message.source = ID;
            message.type = REQUEST;

            var ushort successor = SUCCESSOR(destination);
            if successor == UNREACHABLE then
                BLINK(RED);
                // invalid successor
                return 1;
            else/if successor == ID then
                BLINK(YELLOW);
                // the target is one of my direct successors
                message.target = destination; 
            else
                BLINK(GREEN);
                // the target is reachable through the successor
                message.target = successor;
            end

            qPut(message);
        end
        await 5s;
    end
with
    // sends flood probe every 1 minute
    var generic_msg probe;
    probe.v2 /* route */ = INITIAL_ROUTE;
    loop do
        probe.v1 /* origin */ = ID;
        probe.v2 /* route  */ = probe.v2 + 1;
        probe.v3 /* jumps  */ = 0;
        probe.source = ID;
        probe.type = FLOOD;
        probe.target = BROADCAST;
        BLINK(RED);
        qPut(probe);
        
        // waits for echos
        par/or do
            // fills the successor table with each echo
            loop do
                var echo_msg echo;
                echo = await RECEIVE(ECHO);
                SUCCESSOR(echo.source) = ID;
                loop i, SUCCESSORS_SIZE do
                    if echo.successors[i] != UNREACHABLE then
                        SUCCESSOR(i) = echo.source;
                    end
                end
            end
        with
            // timeouts after 5 seconds
            await 10s; // TODO: 5 is arbitrary
        end
        
        await 1min;
    end
end

// ----------------------------------------
//
else // regular nodes
//
// ----------------------------------------
    
var ushort parent = 0;
var ushort current_route = INITIAL_ROUTE;

par do
    // receives and propagates the flood probes
    loop do
        // receives a probe
        var generic_msg received;
        var generic_msg probe;
        
        received = await RECEIVE(FLOOD);
        // continues the flood
        if received.v2 /* route */ > current_route then
            // updates current route number and alarm destination
            current_route = received.v2 /* route */;
            parent = received.source;
            // creates and sends a new probe
            probe.v1 /* origin */ = received.source;
            probe.v2 /* route  */ = received.v2;
            probe.v3 /* jumps  */ = received.v3 + 1;
            probe.source = ID;
            probe.type = FLOOD;
            probe.target = BROADCAST;
            emit SEND(probe);
            await SEND_DONE;
   
            par/or do
                // waits for echos for a while
                loop do
                    // fills the successor table with each echo
                    var echo_msg echo;
                    echo = await RECEIVE(ECHO);
                    SUCCESSOR(echo.source) = ID;
                    loop i, SUCCESSORS_SIZE do
                        if echo.successors[i] != UNREACHABLE then
                            SUCCESSOR(i) = echo.source;
                        end
                    end
                end
            with
                // timeout is relative to jump count
                var ushort time = 2 * (5 - probe.v3) /* jumps */; // 5 is arbitrary
                await (time)s;
                // sends echo back
                var echo_msg echo;
                echo.successors = successors;
                echo.source = ID;
                echo.type = ECHO;
                echo.target = parent;
                emit SEND(echo);
                await SEND_DONE;
                BLINK(GREEN);
            end
        end
    end
with
    // waits for a temperature request 
    loop do
        var generic_msg request;
        var generic_msg alarm;
        
        request = await RECEIVE(REQUEST);
        
        if request.v1 /* destination */ == ID then // reached destination
            alarm.v1  /* node        */ = ID;
            alarm.v2  /* temperature */ = 27; // TODO
            alarm.source = ID;
            alarm.type = ALARM;
            alarm.target = parent;
            emit SEND(alarm);
            await SEND_DONE();
        else // must send the request forward
            var ushort successor = SUCCESSOR(request.v1 /* destination */);
            if successor == UNREACHABLE then
                // invalid successor
                return 1;
            else/if successor == ID then
                // the target is one of my direct successors
                request.target = request.v1 /* destination */;
            else
                // the target is reachable through the successor
                request.target = successor;
            end
            request.source = ID;
            emit SEND(request);
            await SEND_DONE();
        end
    end
with
    // waits for an alarm 
    loop do
        message = await RECEIVE(ALARM);
        qPut(message);
    end
with
    // processes an alarm from the queue
    loop do
        await Q_READY;
        loop do
            if qSize() <= 0 then
                break;
            end 
            qGet(message);
            message.type = ALARM;
            message.target = parent;
            emit SEND(message);
            await SEND_DONE;
        end
    end
with
    // calculates the temperature every 5 seconds
    // sends an alarm if necessary
    loop do
        emit REQ_TEMP();
        var ushort temperature;
        temperature = await TEMP;
        if temperature >= MAXIMUM_TEMPERATURE then
            message.v1 /* node        */ = ID;
            message.v2 /* temperature */ = temperature;
            message.source = ID;
            message.type = ALARM;
            message.target = parent;
            emit SEND(message);
            await SEND_DONE;
        end
        await 5s;
    end
end

end // node if-else

