#include "/home/terra/TerraNG/terra/TerraNet.defs"

#define FLOOD_TYPE   3
#define ALARM_TYPE   5
#define TEMPERATURE_REQUEST 7
#define ECHO_TEMPERATURE    9

// macros for leds
#define RED    1
#define GREEN  2
#define YELLOW 4
#define ALL    7
#define BLINK(led) emit LEDS(led); await 1s; emit LEDS(OFF);

// macro: blinks and sends a message
#define LED_SEND(led, message) \
    BLINK(led); \
    emit SEND(message); \
    await SEND_DONE; \

pktype floodMessage from radioMsg with
    var ushort origin; // parent node id
    var ushort route;  // known route
    var ushort jumps;  // number of jumps to root
end

pktype alarmMessage from radioMsg with
    var ushort node;        // node that measured the temperature value
    var ushort temperature; // temperature value
end

pktype requestMessage from radioMsg with
    var ushort destination;
end

pktype echoMessage from radioMsg with 
    var ushort id;            // id from echo node
    var ushort[9] successors; // successors of that node (stop at 0)
end

// auxiliary variables
var ushort maximum_temperature = 510;
var ushort initial_route = 0;
var ushort id = getNodeId();
var alarmMessage alarm;
var ubyte queue;

// successor table
#define UNREACHABLE 0
#define SELF        1
#define PARENT      2

#define GRID_WIDTH      4
#define GRID_HEIGHT     4
#define SUCCESSORS_SIZE 16

#define J(n)         (n%10)        // column in the grid
#define I(n)         ((n-J(n))/10) // row in the grid
#define SUCCESSOR(n) successors[GRID_WIDTH * (I(n)-1) + (J(n)-1)]

var ushort[SUCCESSORS_SIZE] successors;
loop i, SUCCESSORS_SIZE do
    successors[i] = UNREACHABLE;
end
SUCCESSOR(id) = SELF;
SUCCESSOR(12) = id;

// ----------------------------------------
//
if id == 11 then // gateway 
//
// ----------------------------------------

par do
    // waits for an alarm
    loop do 
        alarm = await RECEIVE(ALARM_TYPE);
        queue = qPut(alarm);
    end
with
    // processes an alarm from the queue 
    loop do
        await Q_READY;
        loop do
            queue = qGet(alarm);
            alarm.target = 1;
            emit SEND(alarm);
            await SEND_DONE;
            BLINK(ALL);
            if qSize() == 0 then
                break;
            end
        end
    end
with
    // sends request temperature message
    // (if photo value is higher than 500)
    loop do
        emit REQ_PHOTO();
        var ushort value = await PHOTO;
        if value > 400 then
            var requestMessage request;
            request.destination = 12; // arbitrary
            request.source = id;
            request.type = TEMPERATURE_REQUEST;
            
            var ushort node = SUCCESSOR(request.destination);
            if node == UNREACHABLE then // invalid
                return 1;
            else/if node == SELF then   // invalid
                return 1;
            else/if node == PARENT then // invalid
                return 1;
            else/if node == id then // the target is one of my direct successors
                request.target = request.destination;
            else                    // the target is reachable through "node"
                request.target = node;
            end

            LED_SEND(ALL, request);
        end
        await 5s;
    end
with
    // sends flood probe every 1 minute
    var floodMessage probe;
    probe.route = initial_route;
    loop do
        probe.origin = id;
        probe.route = probe.route + 1;
        probe.jumps = 0;
        probe.source = id;
        probe.type = FLOOD_TYPE;
        probe.target = BROADCAST;
        emit LEDS(7);
        emit SEND(probe);
        await SEND_DONE;
        emit LEDS(0);
        await 1min;
    end
end

// ----------------------------------------
//
else // regular nodes
//
// ----------------------------------------
    
var ushort alarm_destination = 0;
var ushort current_route = initial_route;
// var ushort pv; // DEBUG

par do
    // receives and propagates the flood probes
    loop do
        // received probe
        var floodMessage received;
        received = await RECEIVE(FLOOD_TYPE);
        
        // emit REQ_PHOTO(); // DEBUG
        // pv = await PHOTO; // DEBUG
        // if pv <= 400 then // DEBUG

        // sends a probe forward
        if received.route > current_route then
            // emit LEDS(probe.route); // DEBUG
            current_route = received.route;
            alarm_destination = received.source;

            var floodMessage probe;
            probe.origin = received.source;
            probe.route = received.route;
            probe.jumps = received.jumps + 1;
            probe.source = id;
            probe.type = FLOOD_TYPE;
            probe.target = BROADCAST;
            emit SEND(probe);
            await SEND_DONE;
            // emit LEDS(probe.route); // DEBUG

            // espera pelas respostas dos sucessores
            //par/or do
            //    // TODO: envia pro progenitor
            //with
            //    await 10s;
            //end
            // ou espera 10s
        end
        // end // DEBUG
    end
with
    // waits for a temperature request 
    loop do
        // TODO request = ...
        await RECEIVE(TEMPERATURE_REQUEST);
        var alarmMessage alarm;
        alarm.node = id;
        alarm.temperature = 27; // TODO
        alarm.source = id;
        alarm.type = ALARM_TYPE;
        alarm.target = alarm_destination;
        LED_SEND(RED, alarm);
    end
with
    // waits for an alarm 
    loop do
        alarm = await RECEIVE(ALARM_TYPE);
        queue = qPut(alarm);
    end
with
    // processes an alarm from the queue
    loop do
        await Q_READY;
        loop do
            queue = qGet(alarm);
            alarm.type = ALARM_TYPE;
            alarm.target = alarm_destination;
            emit SEND(alarm);
            await SEND_DONE;
            if qSize() == 0 then
                break;
            end
        end
    end
with
    // calculates the temperature every 5 seconds
    // sends an alarm if necessary
    loop do
        emit REQ_TEMP();
        var ushort temperature;
        temperature = await TEMP;
        if temperature >= maximum_temperature then
            emit LED2(ON);
            var alarmMessage temperature_alarm;
            temperature_alarm.node = id;
            temperature_alarm.temperature = temperature;
            temperature_alarm.source = id;
            temperature_alarm.type = ALARM_TYPE;
            temperature_alarm.target = alarm_destination;
            emit SEND(temperature_alarm);
            await SEND_DONE;
        else
            emit LED2(OFF);
        end
        await 5s;
    end
end

end // node if-else

